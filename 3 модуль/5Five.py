# # with -----> __enterd ------------> код внутри блока ------------>  __exit__
# import time

# # Создаем класс - контекстный менеджер. (Этот класс вычисляет время работы какого-либо блока кода)
# class TimeWork:
#     def __init__(self):
#         # Задаем атрибут начала отсчета работы программы
#         self.start = None
    
#     # Описываем метод входа в контекстный менеджер
#     def __enter__(self):
#         self.start = time.time()   # записываю в self.start время начало работы программы
#         # return 1
#         # return self   # увидим, с каким объектом мы работаем

#     # Описываем метод выхода из контектсного менеджера
#     def __exit__(self, exc_type, exc_val, exc_tb):  # метод exit очищает контекст, созданный методом __enter__. Выполняется в любом случае, даже если произошло исключение
#         #exc_type - тип исключения, exc_val - значение исключения, exc_tb - объект трассировки. Обязательные параметры
        
#         # Программа завершает работу ===> сохраняем время работы конца программы
#         self.end = time.time()   # записываю в self.end то время, в которое программа завершила свое выполнение

#         # Вычисляем время работы программы
#         time_work = self.end - self.start   # вычисляю, сколько времени работала программа, вычитая из времени окончания работы программы время ее начало
        
#         print(f'Время работы программы {time_work}')
        
#         # Заглушаем вызываемое исключение TypeError

#         if exc_type is not None:   # если есть любая ошибка (универсальный вариант)
#             return True            # вернуть True(проигнорирует ошибку) (произойдет выход из контекстного менеджера, код после скроки с ошибкой выполнен НЕ БУДЕТ)
        
#         if exc_type is TypeError:   # если ошибка является TypeError
#             return True             # вернуть True(проигнорирует ошибку)
        
# with TimeWork() as t1:   
#     print('будет написано то, сколько будет выполняться код из этого блока кода. Это благодаря классу TimeWork')

#     num_list = [i for i in range (100_000_000)]
#     num_list -= 'kek'   # намеренно создаю исключение, с целью проверки обработки исключений

#     # print(t1)   # будет выведено None, т.к. self.start = None, и в __enter__ нет return
#     # print(t1)   # будет выведено 1, т.л в __enter__ есть return 1

#     print(1/0)
#     print('Если это будет в консоли, то ты плохо понял тему')







# --------------------------------------------------------------------------------------------------------------------------------------------
# итератор и итерируемый объект.        Итреторы имеют свойство опустошаться, из-за которого из необходимо перезагружать, что чаще всего делают в методе __iter__
# итератор - объект, реализующий метод __next__, этот метод должен вернуть следующий элемент или выдать исключение StopIteration, говорящее о полном опустошении итератора
# Итерируемый объект - тот, от которого встроенная функция iter() может получить итератор 
import random

num_list = [1,2,3,4]

# Создаем итератор
list_iter = iter(num_list)

print(next(list_iter))  # будет написано 1
print(next(list_iter))  # 2
print(next(list_iter))  # 3
print(next(list_iter))  # 4

for i in list_iter:
    print(i)   # ничего не будет написано, т.к перед этим я уже прошелся по данному итератору

# создаем свой класс-итератор (генерирует определенное кол-во случайных чисел)
class RandomIter:
    def __init__(self, limit):   # ==
        self.limit = limit   # сюда будет передано кол-во чисел
        self.reload = limit

    def __iter__(self):
        self.limit = self.reload
        return self   
    
    def __next__(self):
        # Если дошли до концца итератора
        if self.limit == 0:
            # Вызываем StopIteration
            raise StopIteration
        self.limit -= 1
        return random.randint(1,100)

    
rand_iter = RandomIter(10)

for rand_int in rand_iter:
    print(rand_int)

for rand_int in rand_iter:   # в этот раз ничего не будет выведено, по rand_iter уже прошлись
    print(rand_int)

    # для решения этой проблемы